import OpenAI from 'openai';
import { getSettings, addHistoryItem } from '../utils/storage';
import { ExtractionResult, ActiveTask, ChatMessage } from '../utils/types';

console.log('Background service worker started');

let currentTask: ActiveTask | null = null;
let abortController: AbortController | null = null;

// Initialize state from storage on startup
chrome.storage.local.get(['currentTask'], (result) => {
  if (result.currentTask) {
    currentTask = result.currentTask;
  }
});

chrome.runtime.onInstalled.addListener(() => {
  console.log('Extension installed');
});

// Listen for messages from Popup
chrome.runtime.onMessage.addListener((message, _sender, sendResponse) => {
  if (message.type === 'START_SUMMARIZATION') {
    startSummarization(message.payload);
    sendResponse({ success: true });
    return true; // async response
  }
  
  if (message.type === 'START_REFINEMENT') {
    const { messages, title } = message.payload;
    startRefinement(messages, title);
    sendResponse({ success: true });
    return true;
  }
  
  if (message.type === 'CANCEL_SUMMARIZATION') {
    if (abortController) {
      abortController.abort();
      abortController = null;
    }
    stopTimer(); // Ensure timer stops immediately
    currentTask = null;
    chrome.storage.local.remove('currentTask');
    broadcastUpdate();
    sendResponse({ success: true });
    return true;
  }
  
  if (message.type === 'GET_STATUS') {
    // Return the memory state which should be in sync with storage
    sendResponse(currentTask);
    return true;
  }
  
  if (message.type === 'CLEAR_STATUS') {
    currentTask = null;
    chrome.storage.local.remove('currentTask');
    sendResponse({ success: true });
    return true;
  }
});

function updateTaskState(newState: Partial<ActiveTask>) {
  currentTask = { ...currentTask, ...newState } as ActiveTask;
  chrome.storage.local.set({ currentTask });
  broadcastUpdate();
}

let timerInterval: NodeJS.Timeout | null = null;
let startTime: number = 0;

function startTimer(baseMessage: string) {
  if (timerInterval) clearInterval(timerInterval);
  startTime = Date.now();
  
  timerInterval = setInterval(() => {
    if (!currentTask) {
      if (timerInterval) clearInterval(timerInterval);
      return;
    }
    
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const message = `${baseMessage} (${elapsed}s)`;
    
    // Update task state without broadcasting every second to avoid UI flicker overkill, 
    // but here we want to show it, so we update storage and broadcast.
    // To optimize, maybe only broadcast if popup is open? 
    // For now, we update the task state.
    currentTask = { ...currentTask, message };
    chrome.storage.local.set({ currentTask });
    broadcastUpdate();
  }, 1000);
}

function stopTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

async function startRefinement(messages: ChatMessage[], title?: string) {
  try {
    abortController = new AbortController();
    // Clear previous task state to avoid pollution, but we will merge new state in updateTaskState
    // so we set currentTask to empty object first if we want a fresh start, 
    // OR we just rely on overwriting fields.
    // For refinement, we want to ensure we track the title.
    
    // Explicitly set the initial state for refinement
    currentTask = {
      status: 'Refining...', 
      message: 'Initializing refinement...', 
      progress: 5,
      conversationHistory: messages,
      title: title
    };
    chrome.storage.local.set({ currentTask });
    broadcastUpdate();

    const settings = await getSettings();
    let effectiveApiKey = settings.apiKeys?.[settings.provider] || settings.apiKey;
    
    if (!effectiveApiKey) {
      throw new Error(`API Key for ${settings.provider} is missing. Please check settings.`);
    }

    const openai = new OpenAI({
      apiKey: effectiveApiKey,
      baseURL: settings.baseUrl,
    });

    updateTaskState({ 
      status: 'Refining...', 
      message: 'Sending instructions to AI...', 
      progress: 30,
      conversationHistory: messages
    });

    // Stream handling logic
    const stream = await openai.chat.completions.create({
      model: settings.model,
      messages: [
        { 
          role: 'system', 
          content: 'You are an expert technical editor. The conversation history contains a markdown document generated by an assistant. The user will ask for changes, optimizations, or extensions to this specific document. You must REWRITE the entire document incorporating these changes based on the existing content. Return ONLY the updated markdown content. Do not generate a new document from scratch unless explicitly asked. Do not include conversational filler like "Here is the updated version".' 
        },
        ...messages.filter(m => m.role !== 'system'),
      ] as any,
      stream: true,
    }, { signal: abortController.signal });

    const baseMessage = 'Generating response...';
    startTimer(baseMessage);

    let refinedContent = '';
    let lastUpdate = Date.now();
    
    for await (const chunk of stream) {
      const content = chunk.choices[0]?.delta?.content || '';
      refinedContent += content;
      
      // Throttle updates to UI every 500ms
      const now = Date.now();
      if (now - lastUpdate > 500) {
        lastUpdate = now;
        // Update in-memory task state and broadcast, but AVOID storage writes for performance
        currentTask = {
          ...currentTask,
          status: 'Refining...',
          message: `${baseMessage} (${Math.floor(refinedContent.length / 100)}k chars)`,
          result: refinedContent, // Live preview
          progress: 50 + Math.min(40, Math.floor(refinedContent.length / 50)) // Fake progress based on length
        } as ActiveTask;
        broadcastUpdate();
      }
    }
    
    stopTimer();

    updateTaskState({ 
      status: 'Refining...', 
      message: 'Processing response...', 
      progress: 90,
      conversationHistory: messages
    });
    
    // Update history with assistant response
    const updatedHistory: ChatMessage[] = [
      ...messages,
      { role: 'assistant', content: refinedContent }
    ];

    // Generate new versioned title
    let newTitle = title || 'Untitled Chat';
    const versionMatch = newTitle.match(/\(v(\d+)\)$/);
    if (versionMatch) {
      const version = parseInt(versionMatch[1], 10) + 1;
      newTitle = newTitle.replace(/\(v\d+\)$/, `(v${version})`);
    } else {
      newTitle = `${newTitle} (v2)`;
    }

    // Save to History
    const newItem = {
      id: Date.now().toString(),
      title: newTitle,
      date: Date.now(),
      content: refinedContent,
      url: '' // We might not have URL here, but that's okay for refined docs
    };
    await addHistoryItem(newItem);

    updateTaskState({ 
      status: 'Refined!', 
      message: 'Refinement complete!',
      progress: 100, 
      result: refinedContent,
      conversationHistory: updatedHistory,
      title: newTitle
    });

  } catch (error: any) {
    stopTimer();
    if (error.name === 'AbortError') {
      console.log('Refinement cancelled');
      return;
    }
    console.error('Refinement error:', error);
    updateTaskState({ 
      status: 'Error', 
      message: error.message || 'Refinement failed',
      progress: 0, 
      error: error.message,
      conversationHistory: messages // Keep history so user can retry
    });
  } finally {
    abortController = null;
    stopTimer();
  }
}

async function startSummarization(extraction: ExtractionResult) {
  try {
    abortController = new AbortController();
    
    // Explicitly reset task for new summarization
    currentTask = { 
      status: 'Processing...', 
      message: 'Initializing...', 
      progress: 5,
      title: extraction.title 
    };
    chrome.storage.local.set({ currentTask });
    broadcastUpdate();

    const settings = await getSettings();
    
    // Determine the effective API Key:
    // 1. Try to get provider-specific key from the new apiKeys map
    // 2. Fallback to the legacy single 'apiKey' if not found
    let effectiveApiKey = settings.apiKeys?.[settings.provider] || settings.apiKey;
    
    // Special handling for 'custom' provider: might rely on the legacy field if not explicitly mapped,
    // but the UI now syncs custom key to apiKeys['custom'] too.
    
    if (!effectiveApiKey) {
      throw new Error(`API Key for ${settings.provider} is missing. Please check settings.`);
    }

    const openai = new OpenAI({
      apiKey: effectiveApiKey,
      baseURL: settings.baseUrl,
    });

    updateTaskState({ status: 'Processing...', message: 'Sending request to AI...', progress: 30 });

    const initialMessages = [
      { role: 'system', content: settings.systemPrompt },
      { 
        role: 'user', 
        content: `Please summarize the following conversation from ${extraction.url}.\n\nTitle: ${extraction.title}\n\nContent:\n${JSON.stringify(extraction.messages)}` 
      }
    ];

    // Create a timeout promise that rejects after 180 seconds (extended for DeepSeek)
    // Note: For stream, we might want a "time to first byte" timeout instead, but 
    // keeping it simple for now: if the whole process takes > 3 mins, kill it.
    const timeoutId = setTimeout(() => {
        if (abortController) {
            abortController.abort();
            // We can't easily reject the await stream loop from outside, 
            // but aborting the controller will throw an AbortError in the loop.
        }
    }, 180000); 

    const stream = await openai.chat.completions.create({
      model: settings.model,
      messages: initialMessages as any,
      stream: true,
    }, { signal: abortController.signal });

    const baseMessage = 'Generating summary...';
    // Initial update to show we are connected
    updateTaskState({ status: 'Processing...', message: baseMessage, progress: 50 });
    startTimer(baseMessage);

    let summary = '';
    let lastUpdate = Date.now();
    let hasReceivedContent = false;

    try {
        for await (const chunk of stream) {
            if (!hasReceivedContent) {
                // First byte received! Clear strict timeout and maybe set a longer one?
                // For now, we rely on the 3min global timeout or user cancel.
                hasReceivedContent = true;
            }

            const content = chunk.choices[0]?.delta?.content || '';
            summary += content;
            
            const now = Date.now();
            if (now - lastUpdate > 500) {
                lastUpdate = now;
                // Update in-memory task state and broadcast
                currentTask = {
                    ...currentTask,
                    status: 'Processing...',
                    message: `${baseMessage} (${Math.floor(summary.length / 100)}k chars)`,
                    result: summary, // Live preview
                    progress: 50 + Math.min(40, Math.floor(summary.length / 100))
                } as ActiveTask;
                broadcastUpdate();
            }
        }
    } finally {
        clearTimeout(timeoutId);
    }
    
    stopTimer();

    updateTaskState({ status: 'Processing...', message: 'Finalizing...', progress: 95 });
    
    // Improved content extraction logic:
    // 1. Check if the ENTIRE content is wrapped in a markdown code block.
    // We only extract if the code block starts at the beginning and ends at the end.
    // This prevents extracting a small internal code block (e.g. a Java example) and losing the rest of the document.
    const outerCodeBlockRegex = /^```(?:markdown)?\s*([\s\S]*?)\s*```$/i;
    const outerMatch = summary.trim().match(outerCodeBlockRegex);
    
    if (outerMatch && outerMatch[1]) {
        // Only if the whole thing is a block, we unwrap it.
        summary = outerMatch[1];
    } else {
        // Otherwise, just strip any accidental leading/trailing backticks if they look like wrappers
        // but be careful not to touch internal code blocks.
        // Actually, if it's not a full wrapper, we assume the content is raw markdown.
        // We just do a safety trim.
        summary = summary.trim();
    }

    // 2. Clean Front Matter: Ensure it starts exactly with "---"
    // Find the FIRST occurrence of "---\n" or "---\r\n" which signifies the start of Front Matter
    // We look for:
    // - "---" followed by newline
    // - followed by typical Front Matter keys like "title:", "date:", "layout:" to reduce false positives
    const frontMatterStartRegex = /---\s*\n(?:\s*title:|\s*date:|\s*layout:)/;
    const match = summary.match(frontMatterStartRegex);
    
    if (match) {
      // If we found a valid Front Matter start, discard everything before it
      summary = summary.slice(match.index);
    } else {
      // Relaxed fallback: just look for the first "---" followed by a newline if the strict check failed
      // This helps if the model output format is slightly off but still has Front Matter
      const simpleMatch = summary.match(/---\s*\n/);
      if (simpleMatch && summary.indexOf('title:', simpleMatch.index!) > simpleMatch.index!) {
         summary = summary.slice(simpleMatch.index);
      }
    }

    // Save to History
    const newItem = {
      id: Date.now().toString(),
      title: extraction.title || 'Untitled Chat',
      date: Date.now(),
      content: summary,
      url: extraction.url
    };
    
    await addHistoryItem(newItem);

    updateTaskState({ 
      status: 'Done!', 
      message: 'Summary generated successfully!',
      progress: 100, 
      result: summary, 
      conversationHistory: [
        ...initialMessages as ChatMessage[],
        { role: 'assistant', content: summary }
      ]
    });

    // Set badge to indicate completion
    chrome.action.setBadgeText({ text: '1' });
    chrome.action.setBadgeBackgroundColor({ color: '#4CAF50' });

    // Send Notification
    const iconUrl = chrome.runtime.getURL('public/icon-128.png');
    chrome.notifications.create({
      type: 'basic',
      iconUrl: iconUrl,
      title: 'Chat Export Complete',
      message: `Summary generated for: ${extraction.title || 'Untitled Chat'}`
    }, (notificationId) => {
      if (chrome.runtime.lastError) {
        console.error('Notification failed:', chrome.runtime.lastError);
      } else {
        console.log('Notification sent:', notificationId);
      }
    });

  } catch (error: any) {
    if (error.name === 'AbortError') {
      console.log('Summarization cancelled');
      return; // Do nothing if cancelled
    }

    console.error('Summarization error:', error);
    updateTaskState({ 
      status: 'Error', 
      message: error.message || 'An error occurred',
      progress: 0, 
      error: error.message 
    });

    // Send Error Notification
    const iconUrl = chrome.runtime.getURL('public/icon-128.png');
    chrome.notifications.create({
      type: 'basic',
      iconUrl: iconUrl,
      title: 'Chat Export Failed',
      message: error.message || 'Unknown error occurred'
    });
  } finally {
    abortController = null;
  }
}

function broadcastUpdate() {
  chrome.runtime.sendMessage({ type: 'STATUS_UPDATE', payload: currentTask }).catch(() => {
    // Popup might be closed, which is expected
  });
}
